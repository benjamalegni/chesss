{"ast":null,"code":"import { TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\";\nexport const pawnMove = (initialPosition, desiredPosition, team, dx, dy, boardState) => {\n  const specialRow = team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n  if (initialPosition.x === desiredPosition.x && initialPosition.y === specialRow && dy === 2 * pawnDirection) {\n    if (!Referee.tileIsOccupied(desiredPosition, boardState) && !Referee.tileIsOccupied({\n      x: desiredPosition.x,\n      y: desiredPosition.y - pawnDirection\n    }, boardState)) {\n      return true;\n    }\n  } else if (initialPosition.x === desiredPosition.x && dy === pawnDirection) {\n    return !Referee.tileIsOccupied(desiredPosition, boardState);\n  }\n  //attack\n  else if (dy === pawnDirection && (dx === -1 || dx === 1)) {\n    return Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  return false;\n};\nexport const GetPossiblePawnMoves = (piece, boardState) => {\n  const possibleMoves = [];\n  const pawnDirection = piece.team === TeamType.OUR ? 1 : -1;\n  const specialRow = piece.team === TeamType.OUR ? 1 : 6;\n\n  // Check all possible moves in a 3x2 grid in front of the pawn\n  for (let y = 1; y <= 2; y++) {\n    for (let x = -1; x <= 1; x++) {\n      // Skip if it's the same position\n      if (x === 0 && y === 1) continue;\n      const desiredPosition = {\n        x: piece.position.x + x,\n        y: piece.position.y + y * pawnDirection\n      };\n\n      // Only check two-square move if pawn is in starting position\n      if (y === 2 && piece.position.y !== specialRow) continue;\n      if (pawnMove(piece.position, desiredPosition, piece.team, x, y * pawnDirection, boardState)) {\n        possibleMoves.push(desiredPosition);\n      }\n    }\n  }\n  return possibleMoves;\n};\n_c = GetPossiblePawnMoves;\nvar _c;\n$RefreshReg$(_c, \"GetPossiblePawnMoves\");","map":{"version":3,"names":["TeamType","Referee","pawnMove","initialPosition","desiredPosition","team","dx","dy","boardState","specialRow","OUR","pawnDirection","x","y","tileIsOccupied","tileIsOccupiedByOpponent","GetPossiblePawnMoves","piece","possibleMoves","position","push","_c","$RefreshReg$"],"sources":["/home/Outer/Documents/chesss/src/referee/rules/PawnRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\n\n    export const pawnMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, boardState:Piece[]):boolean=>{\n            const specialRow = (team === TeamType.OUR)?1:6;\n            const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n            if(initialPosition.x===desiredPosition.x && initialPosition.y===specialRow && dy===2*pawnDirection){\n                if(!Referee.tileIsOccupied(desiredPosition,boardState) && !Referee.tileIsOccupied({x: desiredPosition.x, y:desiredPosition.y-pawnDirection}, boardState)){\n                    return true;\n                }\n            }else if(initialPosition.x===desiredPosition.x && dy===pawnDirection){\n                    return !Referee.tileIsOccupied(desiredPosition,boardState)\n            }\n            //attack\n            else if(dy===pawnDirection && ((dx===-1) || (dx===1))){\n                return Referee.tileIsOccupiedByOpponent(desiredPosition,boardState,team);\n            }\n        return false;\n    }\n\nexport const GetPossiblePawnMoves = (piece:Piece, boardState : Piece[]):Position[] => {\n    const possibleMoves:Position [] = [];\n    const pawnDirection = (piece.team === TeamType.OUR)? 1:-1;\n    const specialRow = (piece.team === TeamType.OUR)? 1:6;\n\n    // Check all possible moves in a 3x2 grid in front of the pawn\n    for(let y = 1; y <= 2; y++) {\n        for(let x = -1; x <= 1; x++) {\n            // Skip if it's the same position\n            if(x === 0 && y === 1) continue;\n\n            const desiredPosition = {\n                x: piece.position.x + x,\n                y: piece.position.y + (y * pawnDirection)\n            };\n\n            // Only check two-square move if pawn is in starting position\n            if(y === 2 && piece.position.y !== specialRow) continue;\n\n            if(pawnMove(piece.position, desiredPosition, piece.team, x, y * pawnDirection, boardState)) {\n                possibleMoves.push(desiredPosition);\n            }\n        }\n    }\n\n    return possibleMoves;\n}"],"mappings":"AAAA,SAA0BA,QAAQ,QAAQ,iBAAiB;AAC3D,OAAOC,OAAO,MAAM,YAAY;AAG5B,OAAO,MAAMC,QAAQ,GAACA,CAACC,eAAwB,EAAEC,eAAyB,EAAEC,IAAa,EAACC,EAAS,EAAEC,EAAS,EAAEC,UAAkB,KAAW;EACrI,MAAMC,UAAU,GAAIJ,IAAI,KAAKL,QAAQ,CAACU,GAAG,GAAE,CAAC,GAAC,CAAC;EAC9C,MAAMC,aAAa,GAAIN,IAAI,KAAKL,QAAQ,CAACU,GAAG,GAAG,CAAC,GAAC,CAAC,CAAC;EAEnD,IAAGP,eAAe,CAACS,CAAC,KAAGR,eAAe,CAACQ,CAAC,IAAIT,eAAe,CAACU,CAAC,KAAGJ,UAAU,IAAIF,EAAE,KAAG,CAAC,GAACI,aAAa,EAAC;IAC/F,IAAG,CAACV,OAAO,CAACa,cAAc,CAACV,eAAe,EAACI,UAAU,CAAC,IAAI,CAACP,OAAO,CAACa,cAAc,CAAC;MAACF,CAAC,EAAER,eAAe,CAACQ,CAAC;MAAEC,CAAC,EAACT,eAAe,CAACS,CAAC,GAACF;IAAa,CAAC,EAAEH,UAAU,CAAC,EAAC;MACrJ,OAAO,IAAI;IACf;EACJ,CAAC,MAAK,IAAGL,eAAe,CAACS,CAAC,KAAGR,eAAe,CAACQ,CAAC,IAAIL,EAAE,KAAGI,aAAa,EAAC;IAC7D,OAAO,CAACV,OAAO,CAACa,cAAc,CAACV,eAAe,EAACI,UAAU,CAAC;EAClE;EACA;EAAA,KACK,IAAGD,EAAE,KAAGI,aAAa,KAAML,EAAE,KAAG,CAAC,CAAC,IAAMA,EAAE,KAAG,CAAE,CAAC,EAAC;IAClD,OAAOL,OAAO,CAACc,wBAAwB,CAACX,eAAe,EAACI,UAAU,EAACH,IAAI,CAAC;EAC5E;EACJ,OAAO,KAAK;AAChB,CAAC;AAEL,OAAO,MAAMW,oBAAoB,GAAGA,CAACC,KAAW,EAAET,UAAoB,KAAgB;EAClF,MAAMU,aAAyB,GAAG,EAAE;EACpC,MAAMP,aAAa,GAAIM,KAAK,CAACZ,IAAI,KAAKL,QAAQ,CAACU,GAAG,GAAG,CAAC,GAAC,CAAC,CAAC;EACzD,MAAMD,UAAU,GAAIQ,KAAK,CAACZ,IAAI,KAAKL,QAAQ,CAACU,GAAG,GAAG,CAAC,GAAC,CAAC;;EAErD;EACA,KAAI,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxB,KAAI,IAAID,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACzB;MACA,IAAGA,CAAC,KAAK,CAAC,IAAIC,CAAC,KAAK,CAAC,EAAE;MAEvB,MAAMT,eAAe,GAAG;QACpBQ,CAAC,EAAEK,KAAK,CAACE,QAAQ,CAACP,CAAC,GAAGA,CAAC;QACvBC,CAAC,EAAEI,KAAK,CAACE,QAAQ,CAACN,CAAC,GAAIA,CAAC,GAAGF;MAC/B,CAAC;;MAED;MACA,IAAGE,CAAC,KAAK,CAAC,IAAII,KAAK,CAACE,QAAQ,CAACN,CAAC,KAAKJ,UAAU,EAAE;MAE/C,IAAGP,QAAQ,CAACe,KAAK,CAACE,QAAQ,EAAEf,eAAe,EAAEa,KAAK,CAACZ,IAAI,EAAEO,CAAC,EAAEC,CAAC,GAAGF,aAAa,EAAEH,UAAU,CAAC,EAAE;QACxFU,aAAa,CAACE,IAAI,CAAChB,eAAe,CAAC;MACvC;IACJ;EACJ;EAEA,OAAOc,aAAa;AACxB,CAAC;AAAAG,EAAA,GA1BYL,oBAAoB;AAAA,IAAAK,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}