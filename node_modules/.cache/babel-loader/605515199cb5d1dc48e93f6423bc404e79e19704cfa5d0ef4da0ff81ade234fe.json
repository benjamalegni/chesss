{"ast":null,"code":"import Referee from \"../Referee\";\n\n// bishop moves\nconst bishopX = [1, 1, -1, -1];\nconst bishopY = [1, -1, 1, -1];\nexport const bishopMove = (initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState) => {\n  // diagonal movement implies that difference between axis should be equal\n  if (Math.abs(dx) === Math.abs(dy)) {\n    // iterate all positions between actual position and desired position (dx or dy)\n    for (let i = 1; i < Math.abs(dx); i++) {\n      // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n      const passedPosition = {\n        x: initialPosition.x + i * stepX,\n        y: initialPosition.y + i * stepY\n      };\n\n      // if any intermediate tile is occupied, then is invalid\n      if (Referee.tileIsOccupied(passedPosition, boardState)) {\n        return false;\n      }\n    }\n\n    // return true (if is not occupied by our team) or (is ocuppied by opponent)\n    return !Referee.tileIsOccupied(desiredPosition, boardState) || Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  return false;\n};\nexport const GetPossibleBishopMoves = (piece, boardState) => {\n  const possibleMoves = [];\n  for (let i = 0; i < 4; i++) {\n    // analyze upper right diagonal\n    // then down right diagonal\n    // then upper left diagonal\n    // then down left diagonal\n\n    let x = piece.position.x + bishopX[i];\n    let y = piece.position.y + bishopY[i];\n\n    // check if the position is on the board\n    while (x >= 0 && x < 8 && y >= 0 && y < 8) {\n      const position = {\n        x,\n        y\n      };\n      //print posible moves\n      if (bishopMove(piece.position, position, piece.team, bishopX[i], bishopY[i], bishopX[i], bishopY[i], boardState)) {\n        possibleMoves.push(position);\n      }\n      //stop if tile is occupied\n      if (Referee.tileIsOccupied(position, boardState)) {\n        break;\n      }\n\n      //move to next tile\n      x += bishopX[i];\n      y += bishopY[i];\n    }\n  }\n  return possibleMoves;\n};\n_c = GetPossibleBishopMoves;\nvar _c;\n$RefreshReg$(_c, \"GetPossibleBishopMoves\");","map":{"version":3,"names":["Referee","bishopX","bishopY","bishopMove","initialPosition","desiredPosition","team","dx","dy","stepX","stepY","boardState","Math","abs","i","passedPosition","x","y","tileIsOccupied","tileIsOccupiedByOpponent","GetPossibleBishopMoves","piece","possibleMoves","position","push","_c","$RefreshReg$"],"sources":["/home/Outer/Documents/chesss/src/referee/rules/BishopRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\n\n// bishop moves\nconst bishopX = [1, 1, -1, -1];\nconst bishopY = [1, -1, 1, -1];\n\nexport const bishopMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean=>{\n            // diagonal movement implies that difference between axis should be equal\n            if (Math.abs(dx) === Math.abs(dy)) {\n\n                // iterate all positions between actual position and desired position (dx or dy)\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (Referee.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !Referee.tileIsOccupied(desiredPosition, boardState) ||\n                    Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n            }\n        return false;\n        }\n\n\nexport const GetPossibleBishopMoves = (piece:Piece, boardState:Piece[]):Position[]=>{\n    const possibleMoves:Position[] = [];\n\n \n    for(let i=0;i<4;i++){\n        // analyze upper right diagonal\n        // then down right diagonal\n        // then upper left diagonal\n        // then down left diagonal\n\n\n        let x = piece.position.x + bishopX[i];\n        let y = piece.position.y + bishopY[i];\n        \n        // check if the position is on the board\n        while(x >= 0 && x < 8 && y >= 0 && y < 8) {\n            const position = {x, y};\n            //print posible moves\n            if(bishopMove(piece.position, position, piece.team, bishopX[i], bishopY[i], bishopX[i], bishopY[i], boardState)){\n                possibleMoves.push(position);\n            }\n            //stop if tile is occupied\n            if(Referee.tileIsOccupied(position, boardState)) {\n                break;\n            }\n\n            //move to next tile\n            x += bishopX[i];\n            y += bishopY[i];\n        }\n    }\n    return possibleMoves;\n}\n"],"mappings":"AACA,OAAOA,OAAO,MAAM,YAAY;;AAGhC;AACA,MAAMC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC9B,MAAMC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAE9B,OAAO,MAAMC,UAAU,GAACA,CAACC,eAAwB,EAAEC,eAAyB,EAAEC,IAAa,EAACC,EAAS,EAAEC,EAAS,EAAEC,KAAY,EAAEC,KAAY,EAAEC,UAAkB,KAAW;EAC/J;EACA,IAAIC,IAAI,CAACC,GAAG,CAACN,EAAE,CAAC,KAAKK,IAAI,CAACC,GAAG,CAACL,EAAE,CAAC,EAAE;IAE/B;IACA,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACC,GAAG,CAACN,EAAE,CAAC,EAAEO,CAAC,EAAE,EAAE;MACnC;MACA,MAAMC,cAAwB,GAAG;QAC7BC,CAAC,EAAEZ,eAAe,CAACY,CAAC,GAAGF,CAAC,GAAGL,KAAK;QAChCQ,CAAC,EAAEb,eAAe,CAACa,CAAC,GAAGH,CAAC,GAAGJ;MAC/B,CAAC;;MAED;MACA,IAAIV,OAAO,CAACkB,cAAc,CAACH,cAAc,EAAEJ,UAAU,CAAC,EAAE;QACpD,OAAO,KAAK;MAChB;IACJ;;IAEA;IACA,OAAO,CAACX,OAAO,CAACkB,cAAc,CAACb,eAAe,EAAEM,UAAU,CAAC,IACvDX,OAAO,CAACmB,wBAAwB,CAACd,eAAe,EAAEM,UAAU,EAAEL,IAAI,CAAC;EAC3E;EACJ,OAAO,KAAK;AACZ,CAAC;AAGT,OAAO,MAAMc,sBAAsB,GAAGA,CAACC,KAAW,EAAEV,UAAkB,KAAc;EAChF,MAAMW,aAAwB,GAAG,EAAE;EAGnC,KAAI,IAAIR,CAAC,GAAC,CAAC,EAACA,CAAC,GAAC,CAAC,EAACA,CAAC,EAAE,EAAC;IAChB;IACA;IACA;IACA;;IAGA,IAAIE,CAAC,GAAGK,KAAK,CAACE,QAAQ,CAACP,CAAC,GAAGf,OAAO,CAACa,CAAC,CAAC;IACrC,IAAIG,CAAC,GAAGI,KAAK,CAACE,QAAQ,CAACN,CAAC,GAAGf,OAAO,CAACY,CAAC,CAAC;;IAErC;IACA,OAAME,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAG,CAAC,IAAIC,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAG,CAAC,EAAE;MACtC,MAAMM,QAAQ,GAAG;QAACP,CAAC;QAAEC;MAAC,CAAC;MACvB;MACA,IAAGd,UAAU,CAACkB,KAAK,CAACE,QAAQ,EAAEA,QAAQ,EAAEF,KAAK,CAACf,IAAI,EAAEL,OAAO,CAACa,CAAC,CAAC,EAAEZ,OAAO,CAACY,CAAC,CAAC,EAAEb,OAAO,CAACa,CAAC,CAAC,EAAEZ,OAAO,CAACY,CAAC,CAAC,EAAEH,UAAU,CAAC,EAAC;QAC5GW,aAAa,CAACE,IAAI,CAACD,QAAQ,CAAC;MAChC;MACA;MACA,IAAGvB,OAAO,CAACkB,cAAc,CAACK,QAAQ,EAAEZ,UAAU,CAAC,EAAE;QAC7C;MACJ;;MAEA;MACAK,CAAC,IAAIf,OAAO,CAACa,CAAC,CAAC;MACfG,CAAC,IAAIf,OAAO,CAACY,CAAC,CAAC;IACnB;EACJ;EACA,OAAOQ,aAAa;AACxB,CAAC;AAAAG,EAAA,GAhCYL,sBAAsB;AAAA,IAAAK,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}