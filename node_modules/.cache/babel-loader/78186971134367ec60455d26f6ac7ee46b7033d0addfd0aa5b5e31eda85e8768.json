{"ast":null,"code":"import Referee from\"../Referee\";export const rookMove=(initialPosition,desiredPosition,team,dx,dy,stepX,stepY,boardState)=>{// vertical movement\nif(dx===0){// iterate all positions between actual position and desired position dy\nfor(let i=1;i<Math.abs(dy);i++){// maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\nconst passedPosition={x:initialPosition.x,y:initialPosition.y+i*stepY};// if any intermediate tile is occupied, then is invalid\nif(Referee.tileIsOccupied(passedPosition,boardState)){return false;}}}// horizontal movement\nelse if(dy===0){// iterate all positions between actual position and desired position dx\nfor(let i=1;i<Math.abs(dx);i++){// maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\nconst passedPosition={x:initialPosition.x+i*stepX,y:initialPosition.y};// if any intermediate tile is occupied, then is invalid\nif(Referee.tileIsOccupied(passedPosition,boardState)){return false;}}}else{// if its not vertical nor horizontal movement\nreturn false;}// return true (if is not occupied by our team) or (is ocuppied by opponent)\nreturn!Referee.tileIsOccupied(desiredPosition,boardState)||Referee.tileIsOccupiedByOpponent(desiredPosition,boardState,team);};","map":{"version":3,"names":["Referee","rookMove","initialPosition","desiredPosition","team","dx","dy","stepX","stepY","boardState","i","Math","abs","passedPosition","x","y","tileIsOccupied","tileIsOccupiedByOpponent"],"sources":["/home/Outer/Documents/CHESSS/src/referee/rules/RookRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\nexport const rookMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean=>{\n            // vertical movement\n            if (dx === 0){\n                // iterate all positions between actual position and desired position dy\n                for (let i = 1; i < Math.abs(dy); i++) {\n                    // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (Referee.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } // horizontal movement\n            else if (dy === 0) {\n                // iterate all positions between actual position and desired position dx\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (Referee.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } else {\n            // if its not vertical nor horizontal movement\n            return false;\n        }\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !Referee.tileIsOccupied(desiredPosition, boardState) ||\n                    Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n"],"mappings":"AACA,MAAO,CAAAA,OAAO,KAAM,YAAY,CAEhC,MAAO,MAAM,CAAAC,QAAQ,CAACA,CAACC,eAAwB,CAAEC,eAAyB,CAAEC,IAAa,CAACC,EAAS,CAAEC,EAAS,CAAEC,KAAY,CAAEC,KAAY,CAAEC,UAAkB,GAAW,CAC7J;AACA,GAAIJ,EAAE,GAAK,CAAC,CAAC,CACT;AACA,IAAK,GAAI,CAAAK,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGC,IAAI,CAACC,GAAG,CAACN,EAAE,CAAC,CAAEI,CAAC,EAAE,CAAE,CACnC;AACA,KAAM,CAAAG,cAAwB,CAAG,CAC7BC,CAAC,CAAEZ,eAAe,CAACY,CAAC,CACpBC,CAAC,CAAEb,eAAe,CAACa,CAAC,CAAGL,CAAC,CAAGF,KAC/B,CAAC,CAED;AACA,GAAIR,OAAO,CAACgB,cAAc,CAACH,cAAc,CAAEJ,UAAU,CAAC,CAAE,CACpD,MAAO,MAAK,CAChB,CACJ,CACJ,CAAE;AAAA,IACG,IAAIH,EAAE,GAAK,CAAC,CAAE,CACf;AACA,IAAK,GAAI,CAAAI,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGC,IAAI,CAACC,GAAG,CAACP,EAAE,CAAC,CAAEK,CAAC,EAAE,CAAE,CACnC;AACA,KAAM,CAAAG,cAAwB,CAAG,CAC7BC,CAAC,CAAEZ,eAAe,CAACY,CAAC,CAAGJ,CAAC,CAAGH,KAAK,CAChCQ,CAAC,CAAEb,eAAe,CAACa,CACvB,CAAC,CAED;AACA,GAAIf,OAAO,CAACgB,cAAc,CAACH,cAAc,CAAEJ,UAAU,CAAC,CAAE,CACpD,MAAO,MAAK,CAChB,CACJ,CACJ,CAAC,IAAM,CACP;AACA,MAAO,MAAK,CAChB,CACQ;AACA,MAAO,CAACT,OAAO,CAACgB,cAAc,CAACb,eAAe,CAAEM,UAAU,CAAC,EACvDT,OAAO,CAACiB,wBAAwB,CAACd,eAAe,CAAEM,UAAU,CAAEL,IAAI,CAAC,CACnF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}