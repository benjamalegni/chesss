{"ast":null,"code":"import Referee from \"../Referee\";\n\n// rook moves\nconst rookX = [1, -1, 0, 0];\nconst rookY = [0, 0, 1, -1];\nexport const rookMove = (initialPosition, desiredPosition, team, dx, dy, stepX, stepY, boardState) => {\n  // vertical movement\n  if (dx === 0) {\n    // iterate all positions between actual position and desired position dy\n    for (let i = 1; i < Math.abs(dy); i++) {\n      // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n      const passedPosition = {\n        x: initialPosition.x,\n        y: initialPosition.y + i * stepY\n      };\n\n      // if any intermediate tile is occupied, then is invalid\n      if (Referee.tileIsOccupied(passedPosition, boardState)) {\n        return false;\n      }\n    }\n  } // horizontal movement\n  else if (dy === 0) {\n    // iterate all positions between actual position and desired position dx\n    for (let i = 1; i < Math.abs(dx); i++) {\n      // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n      const passedPosition = {\n        x: initialPosition.x + i * stepX,\n        y: initialPosition.y\n      };\n\n      // if any intermediate tile is occupied, then is invalid\n      if (Referee.tileIsOccupied(passedPosition, boardState)) {\n        return false;\n      }\n    }\n  } else {\n    // if its not vertical nor horizontal movement\n    return false;\n  }\n  // return true (if is not occupied by our team) or (is ocuppied by opponent)\n  return !Referee.tileIsOccupied(desiredPosition, boardState) || Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n};\nexport const GetPossibleRookMoves = (piece, boardState) => {\n  const possibleMoves = [];\n  for (let i = 0; i < 4; i++) {\n    let x = piece.position.x + rookX[i];\n    let y = piece.position.y + rookY[i];\n    while (x >= 0 && x < 8 && y >= 0 && y < 8) {\n      const position = {\n        x,\n        y\n      };\n      if (rookMove(piece.position, position, piece.team, rookX[i], rookY[i], rookX[i], rookY[i], boardState)) {\n        possibleMoves.push(position);\n      }\n      if (Referee.tileIsOccupied(position, boardState)) {\n        break;\n      }\n      x += rookX[i];\n      y += rookY[i];\n    }\n  }\n  return possibleMoves;\n};\n_c = GetPossibleRookMoves;\nvar _c;\n$RefreshReg$(_c, \"GetPossibleRookMoves\");","map":{"version":3,"names":["Referee","rookX","rookY","rookMove","initialPosition","desiredPosition","team","dx","dy","stepX","stepY","boardState","i","Math","abs","passedPosition","x","y","tileIsOccupied","tileIsOccupiedByOpponent","GetPossibleRookMoves","piece","possibleMoves","position","push","_c","$RefreshReg$"],"sources":["/home/Outer/Documents/chesss/src/referee/rules/RookRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\n\n// rook moves\nconst rookX = [1, -1, 0, 0];\nconst rookY = [0, 0, 1, -1];\n\nexport const rookMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean=>{\n            // vertical movement\n            if (dx === 0){\n                // iterate all positions between actual position and desired position dy\n                for (let i = 1; i < Math.abs(dy); i++) {\n                    // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (Referee.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } // horizontal movement\n            else if (dy === 0) {\n                // iterate all positions between actual position and desired position dx\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (Referee.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } else {\n            // if its not vertical nor horizontal movement\n            return false;\n        }\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !Referee.tileIsOccupied(desiredPosition, boardState) ||\n                    Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n\n    export const GetPossibleRookMoves = (piece:Piece, boardState:Piece[]):Position[]=>{\n        const possibleMoves:Position[] = [];\n\n        for(let i=0;i<4;i++){\n            let x = piece.position.x + rookX[i];\n            let y = piece.position.y + rookY[i];\n\n            while(x >= 0 && x < 8 && y >= 0 && y < 8){\n                const position = {x, y};\n                if(rookMove(piece.position, position, piece.team, rookX[i], rookY[i], rookX[i], rookY[i], boardState)){\n                    possibleMoves.push(position);\n                }\n                if(Referee.tileIsOccupied(position, boardState)){\n                    break;\n                }\n                \n                x+=rookX[i];\n                y+=rookY[i];\n            }\n        }\n        return possibleMoves;\n    }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}