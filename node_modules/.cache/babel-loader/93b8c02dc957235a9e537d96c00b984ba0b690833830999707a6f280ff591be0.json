{"ast":null,"code":"import Referee from\"../Referee\";// bishop moves\nconst bishopX=[1,1,-1,-1];const bishopY=[1,-1,1,-1];export const bishopMove=(initialPosition,desiredPosition,team,dx,dy,stepX,stepY,boardState)=>{// diagonal movement implies that difference between axis should be equal\nif(Math.abs(dx)===Math.abs(dy)){// iterate all positions between actual position and desired position (dx or dy)\nfor(let i=1;i<Math.abs(dx);i++){// change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\nconst passedPosition={x:initialPosition.x+i*stepX,y:initialPosition.y+i*stepY};// if any intermediate tile is occupied, then is invalid\nif(Referee.tileIsOccupied(passedPosition,boardState)){return false;}}// return true (if is not occupied by our team) or (is ocuppied by opponent)\nreturn!Referee.tileIsOccupied(desiredPosition,boardState)||Referee.tileIsOccupiedByOpponent(desiredPosition,boardState,team);}return false;};export const GetPossibleBishopMoves=(piece,boardState)=>{const possibleMoves=[];for(let i=0;i<4;i++){// analyze upper right diagonal\n// then down right diagonal\n// then upper left diagonal\n// then down left diagonal\nlet x=piece.position.x+bishopX[i];let y=piece.position.y+bishopY[i];// check if the position is on the board\nwhile(x>=0&&x<8&&y>=0&&y<8){const position={x,y};//print posible moves\nif(bishopMove(piece.position,position,piece.team,bishopX[i],bishopY[i],bishopX[i],bishopY[i],boardState)){possibleMoves.push(position);}//stop if tile is occupied\nif(Referee.tileIsOccupied(position,boardState)){break;}//move to next tile\nx+=bishopX[i];y+=bishopY[i];}}return possibleMoves;};","map":{"version":3,"names":["Referee","bishopX","bishopY","bishopMove","initialPosition","desiredPosition","team","dx","dy","stepX","stepY","boardState","Math","abs","i","passedPosition","x","y","tileIsOccupied","tileIsOccupiedByOpponent","GetPossibleBishopMoves","piece","possibleMoves","position","push"],"sources":["/home/Outer/Documents/chesss/src/referee/rules/BishopRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\n\n// bishop moves\nconst bishopX = [1, 1, -1, -1];\nconst bishopY = [1, -1, 1, -1];\n\nexport const bishopMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean=>{\n            // diagonal movement implies that difference between axis should be equal\n            if (Math.abs(dx) === Math.abs(dy)) {\n\n                // iterate all positions between actual position and desired position (dx or dy)\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (Referee.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !Referee.tileIsOccupied(desiredPosition, boardState) ||\n                    Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n            }\n        return false;\n        }\n\n\nexport const GetPossibleBishopMoves = (piece:Piece, boardState:Piece[]):Position[]=>{\n    const possibleMoves:Position[] = [];\n\n \n    for(let i=0;i<4;i++){\n        // analyze upper right diagonal\n        // then down right diagonal\n        // then upper left diagonal\n        // then down left diagonal\n\n\n        let x = piece.position.x + bishopX[i];\n        let y = piece.position.y + bishopY[i];\n        \n        // check if the position is on the board\n        while(x >= 0 && x < 8 && y >= 0 && y < 8) {\n            const position = {x, y};\n            //print posible moves\n            if(bishopMove(piece.position, position, piece.team, bishopX[i], bishopY[i], bishopX[i], bishopY[i], boardState)){\n                possibleMoves.push(position);\n            }\n            //stop if tile is occupied\n            if(Referee.tileIsOccupied(position, boardState)) {\n                break;\n            }\n\n            //move to next tile\n            x += bishopX[i];\n            y += bishopY[i];\n        }\n    }\n    return possibleMoves;\n}\n"],"mappings":"AACA,MAAO,CAAAA,OAAO,KAAM,YAAY,CAGhC;AACA,KAAM,CAAAC,OAAO,CAAG,CAAC,CAAC,CAAE,CAAC,CAAE,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,CAC9B,KAAM,CAAAC,OAAO,CAAG,CAAC,CAAC,CAAE,CAAC,CAAC,CAAE,CAAC,CAAE,CAAC,CAAC,CAAC,CAE9B,MAAO,MAAM,CAAAC,UAAU,CAACA,CAACC,eAAwB,CAAEC,eAAyB,CAAEC,IAAa,CAACC,EAAS,CAAEC,EAAS,CAAEC,KAAY,CAAEC,KAAY,CAAEC,UAAkB,GAAW,CAC/J;AACA,GAAIC,IAAI,CAACC,GAAG,CAACN,EAAE,CAAC,GAAKK,IAAI,CAACC,GAAG,CAACL,EAAE,CAAC,CAAE,CAE/B;AACA,IAAK,GAAI,CAAAM,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGF,IAAI,CAACC,GAAG,CAACN,EAAE,CAAC,CAAEO,CAAC,EAAE,CAAE,CACnC;AACA,KAAM,CAAAC,cAAwB,CAAG,CAC7BC,CAAC,CAAEZ,eAAe,CAACY,CAAC,CAAGF,CAAC,CAAGL,KAAK,CAChCQ,CAAC,CAAEb,eAAe,CAACa,CAAC,CAAGH,CAAC,CAAGJ,KAC/B,CAAC,CAED;AACA,GAAIV,OAAO,CAACkB,cAAc,CAACH,cAAc,CAAEJ,UAAU,CAAC,CAAE,CACpD,MAAO,MAAK,CAChB,CACJ,CAEA;AACA,MAAO,CAACX,OAAO,CAACkB,cAAc,CAACb,eAAe,CAAEM,UAAU,CAAC,EACvDX,OAAO,CAACmB,wBAAwB,CAACd,eAAe,CAAEM,UAAU,CAAEL,IAAI,CAAC,CAC3E,CACJ,MAAO,MAAK,CACZ,CAAC,CAGT,MAAO,MAAM,CAAAc,sBAAsB,CAAGA,CAACC,KAAW,CAAEV,UAAkB,GAAc,CAChF,KAAM,CAAAW,aAAwB,CAAG,EAAE,CAGnC,IAAI,GAAI,CAAAR,CAAC,CAAC,CAAC,CAACA,CAAC,CAAC,CAAC,CAACA,CAAC,EAAE,CAAC,CAChB;AACA;AACA;AACA;AAGA,GAAI,CAAAE,CAAC,CAAGK,KAAK,CAACE,QAAQ,CAACP,CAAC,CAAGf,OAAO,CAACa,CAAC,CAAC,CACrC,GAAI,CAAAG,CAAC,CAAGI,KAAK,CAACE,QAAQ,CAACN,CAAC,CAAGf,OAAO,CAACY,CAAC,CAAC,CAErC;AACA,MAAME,CAAC,EAAI,CAAC,EAAIA,CAAC,CAAG,CAAC,EAAIC,CAAC,EAAI,CAAC,EAAIA,CAAC,CAAG,CAAC,CAAE,CACtC,KAAM,CAAAM,QAAQ,CAAG,CAACP,CAAC,CAAEC,CAAC,CAAC,CACvB;AACA,GAAGd,UAAU,CAACkB,KAAK,CAACE,QAAQ,CAAEA,QAAQ,CAAEF,KAAK,CAACf,IAAI,CAAEL,OAAO,CAACa,CAAC,CAAC,CAAEZ,OAAO,CAACY,CAAC,CAAC,CAAEb,OAAO,CAACa,CAAC,CAAC,CAAEZ,OAAO,CAACY,CAAC,CAAC,CAAEH,UAAU,CAAC,CAAC,CAC5GW,aAAa,CAACE,IAAI,CAACD,QAAQ,CAAC,CAChC,CACA;AACA,GAAGvB,OAAO,CAACkB,cAAc,CAACK,QAAQ,CAAEZ,UAAU,CAAC,CAAE,CAC7C,MACJ,CAEA;AACAK,CAAC,EAAIf,OAAO,CAACa,CAAC,CAAC,CACfG,CAAC,EAAIf,OAAO,CAACY,CAAC,CAAC,CACnB,CACJ,CACA,MAAO,CAAAQ,aAAa,CACxB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}