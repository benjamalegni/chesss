{"ast":null,"code":"import { TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\";\nexport const pawnMove = (initialPosition, desiredPosition, team, dx, dy, boardState) => {\n  const specialRow = team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n  if (initialPosition.x === desiredPosition.x && initialPosition.y === specialRow && dy === 2 * pawnDirection) {\n    if (!Referee.tileIsOccupied(desiredPosition, boardState) && !Referee.tileIsOccupied({\n      x: desiredPosition.x,\n      y: desiredPosition.y - pawnDirection\n    }, boardState)) {\n      return true;\n    }\n  } else if (initialPosition.x === desiredPosition.x && dy === pawnDirection) {\n    return !Referee.tileIsOccupied(desiredPosition, boardState);\n  }\n  //attack\n  else if (dy === pawnDirection && (dx === -1 || dx === 1)) {\n    return Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  return false;\n};\nexport const GetPossiblePawnMoves = (piece, boardState) => {\n  const possibleMoves = [];\n  const pawnDirection = piece.team === TeamType.OUR ? 1 : -1;\n  const specialRow = piece.team === TeamType.OUR ? 1 : 6;\n\n  // Forward move (one square)\n  const forwardPosition = {\n    x: piece.position.x,\n    y: piece.position.y + pawnDirection\n  };\n  if (pawnMove(piece.position, forwardPosition, piece.team, 0, pawnDirection, boardState)) {\n    possibleMoves.push(forwardPosition);\n\n    // Initial two-square move\n    if (piece.position.y === specialRow) {\n      const twoSquarePosition = {\n        x: piece.position.x,\n        y: piece.position.y + 2 * pawnDirection\n      };\n      if (pawnMove(piece.position, twoSquarePosition, piece.team, 0, 2 * pawnDirection, boardState)) {\n        possibleMoves.push(twoSquarePosition);\n      }\n    }\n  }\n\n  // Diagonal attacks\n  for (let x = -1; x <= 1; x += 2) {\n    const attackPosition = {\n      x: piece.position.x + x,\n      y: piece.position.y + pawnDirection\n    };\n    if (pawnMove(piece.position, attackPosition, piece.team, x, pawnDirection, boardState)) {\n      possibleMoves.push(attackPosition);\n    }\n  }\n  return possibleMoves;\n};\n_c = GetPossiblePawnMoves;\nvar _c;\n$RefreshReg$(_c, \"GetPossiblePawnMoves\");","map":{"version":3,"names":["TeamType","Referee","pawnMove","initialPosition","desiredPosition","team","dx","dy","boardState","specialRow","OUR","pawnDirection","x","y","tileIsOccupied","tileIsOccupiedByOpponent","GetPossiblePawnMoves","piece","possibleMoves","forwardPosition","position","push","twoSquarePosition","attackPosition","_c","$RefreshReg$"],"sources":["/home/Outer/Documents/chesss/src/referee/rules/PawnRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\n\n    export const pawnMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, boardState:Piece[]):boolean=>{\n            const specialRow = (team === TeamType.OUR)?1:6;\n            const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n            if(initialPosition.x===desiredPosition.x && initialPosition.y===specialRow && dy===2*pawnDirection){\n                if(!Referee.tileIsOccupied(desiredPosition,boardState) && !Referee.tileIsOccupied({x: desiredPosition.x, y:desiredPosition.y-pawnDirection}, boardState)){\n                    return true;\n                }\n            }else if(initialPosition.x===desiredPosition.x && dy===pawnDirection){\n                    return !Referee.tileIsOccupied(desiredPosition,boardState)\n            }\n            //attack\n            else if(dy===pawnDirection && ((dx===-1) || (dx===1))){\n                return Referee.tileIsOccupiedByOpponent(desiredPosition,boardState,team);\n            }\n        return false;\n    }\n\nexport const GetPossiblePawnMoves = (piece:Piece, boardState : Piece[]):Position[] => {\n    const possibleMoves:Position [] = [];\n    const pawnDirection = (piece.team === TeamType.OUR)? 1:-1;\n    const specialRow = (piece.team === TeamType.OUR)? 1:6;\n\n    // Forward move (one square)\n    const forwardPosition = {x: piece.position.x, y: piece.position.y + pawnDirection};\n    if(pawnMove(piece.position, forwardPosition, piece.team, 0, pawnDirection, boardState)) {\n        possibleMoves.push(forwardPosition);\n        \n        // Initial two-square move\n        if(piece.position.y === specialRow) {\n            const twoSquarePosition = {x: piece.position.x, y: piece.position.y + 2 * pawnDirection};\n            if(pawnMove(piece.position, twoSquarePosition, piece.team, 0, 2 * pawnDirection, boardState)) {\n                possibleMoves.push(twoSquarePosition);\n            }\n        }\n    }\n\n    // Diagonal attacks\n    for(let x=-1; x<=1; x+=2) {\n        const attackPosition = {x: piece.position.x + x, y: piece.position.y + pawnDirection};\n        if(pawnMove(piece.position, attackPosition, piece.team, x, pawnDirection, boardState)) {\n            possibleMoves.push(attackPosition);\n        }\n    }\n\n    return possibleMoves;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}