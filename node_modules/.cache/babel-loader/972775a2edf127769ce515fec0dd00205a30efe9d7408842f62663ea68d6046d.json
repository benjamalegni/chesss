{"ast":null,"code":"import { TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\";\nexport const pawnMove = (initialPosition, desiredPosition, team, dx, dy, boardState) => {\n  const specialRow = team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n  if (initialPosition.x === desiredPosition.x && initialPosition.y === specialRow && dy === 2 * pawnDirection) {\n    if (!Referee.tileIsOccupied(desiredPosition, boardState) && !Referee.tileIsOccupied({\n      x: desiredPosition.x,\n      y: desiredPosition.y - pawnDirection\n    }, boardState)) {\n      return true;\n    }\n  } else if (initialPosition.x === desiredPosition.x && dy === pawnDirection) {\n    return !Referee.tileIsOccupied(desiredPosition, boardState);\n  }\n  //attack\n  else if (dy === pawnDirection && (dx === -1 || dx === 1)) {\n    return Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  return false;\n};\nexport const GetPossiblePawnMoves = (piece, boardState) => {\n  const possibleMoves = [];\n  const pawnDirection = piece.team === TeamType.OUR ? 1 : -1;\n  for (let y = 1; y < 3; y++) {\n    for (let x = -1; x < 2; x++) {\n      // if x=pawn position\n      if (x === 0) continue;\n      const desiredPosition = {\n        x: piece.position.x + x,\n        y: piece.position.y + pawnDirection\n      };\n      if (pawnMove(piece.position, desiredPosition, piece.team, x, pawnDirection, boardState)) {\n        possibleMoves.push(desiredPosition);\n      }\n    }\n  }\n  return possibleMoves;\n};\n_c = GetPossiblePawnMoves;\nvar _c;\n$RefreshReg$(_c, \"GetPossiblePawnMoves\");","map":{"version":3,"names":["TeamType","Referee","pawnMove","initialPosition","desiredPosition","team","dx","dy","boardState","specialRow","OUR","pawnDirection","x","y","tileIsOccupied","tileIsOccupiedByOpponent","GetPossiblePawnMoves","piece","possibleMoves","position","push","_c","$RefreshReg$"],"sources":["/home/Outer/Documents/chesss/src/referee/rules/PawnRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\n\n    export const pawnMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, boardState:Piece[]):boolean=>{\n            const specialRow = (team === TeamType.OUR)?1:6;\n            const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n            if(initialPosition.x===desiredPosition.x && initialPosition.y===specialRow && dy===2*pawnDirection){\n                if(!Referee.tileIsOccupied(desiredPosition,boardState) && !Referee.tileIsOccupied({x: desiredPosition.x, y:desiredPosition.y-pawnDirection}, boardState)){\n                    return true;\n                }\n            }else if(initialPosition.x===desiredPosition.x && dy===pawnDirection){\n                    return !Referee.tileIsOccupied(desiredPosition,boardState)\n            }\n            //attack\n            else if(dy===pawnDirection && ((dx===-1) || (dx===1))){\n                return Referee.tileIsOccupiedByOpponent(desiredPosition,boardState,team);\n            }\n        return false;\n    }\n\nexport const GetPossiblePawnMoves = (piece:Piece, boardState : Piece[]):Position[] => {\n    const possibleMoves:Position [] = [];\n    const pawnDirection = (piece.team === TeamType.OUR)? 1:-1;\n    \n\n    for(let y=1;y<3;y++){\n        for(let x=-1;x<2;x++){\n            // if x=pawn position\n            if(x===0) continue;\n\n            const desiredPosition = {x:piece.position.x + x, y:piece.position.y + pawnDirection};\n            if(pawnMove(piece.position, desiredPosition, piece.team, x, pawnDirection, boardState)){\n                possibleMoves.push(desiredPosition);\n            }\n        }\n    }\n\n    return possibleMoves;\n}"],"mappings":"AAAA,SAA0BA,QAAQ,QAAQ,iBAAiB;AAC3D,OAAOC,OAAO,MAAM,YAAY;AAG5B,OAAO,MAAMC,QAAQ,GAACA,CAACC,eAAwB,EAAEC,eAAyB,EAAEC,IAAa,EAACC,EAAS,EAAEC,EAAS,EAAEC,UAAkB,KAAW;EACrI,MAAMC,UAAU,GAAIJ,IAAI,KAAKL,QAAQ,CAACU,GAAG,GAAE,CAAC,GAAC,CAAC;EAC9C,MAAMC,aAAa,GAAIN,IAAI,KAAKL,QAAQ,CAACU,GAAG,GAAG,CAAC,GAAC,CAAC,CAAC;EAEnD,IAAGP,eAAe,CAACS,CAAC,KAAGR,eAAe,CAACQ,CAAC,IAAIT,eAAe,CAACU,CAAC,KAAGJ,UAAU,IAAIF,EAAE,KAAG,CAAC,GAACI,aAAa,EAAC;IAC/F,IAAG,CAACV,OAAO,CAACa,cAAc,CAACV,eAAe,EAACI,UAAU,CAAC,IAAI,CAACP,OAAO,CAACa,cAAc,CAAC;MAACF,CAAC,EAAER,eAAe,CAACQ,CAAC;MAAEC,CAAC,EAACT,eAAe,CAACS,CAAC,GAACF;IAAa,CAAC,EAAEH,UAAU,CAAC,EAAC;MACrJ,OAAO,IAAI;IACf;EACJ,CAAC,MAAK,IAAGL,eAAe,CAACS,CAAC,KAAGR,eAAe,CAACQ,CAAC,IAAIL,EAAE,KAAGI,aAAa,EAAC;IAC7D,OAAO,CAACV,OAAO,CAACa,cAAc,CAACV,eAAe,EAACI,UAAU,CAAC;EAClE;EACA;EAAA,KACK,IAAGD,EAAE,KAAGI,aAAa,KAAML,EAAE,KAAG,CAAC,CAAC,IAAMA,EAAE,KAAG,CAAE,CAAC,EAAC;IAClD,OAAOL,OAAO,CAACc,wBAAwB,CAACX,eAAe,EAACI,UAAU,EAACH,IAAI,CAAC;EAC5E;EACJ,OAAO,KAAK;AAChB,CAAC;AAEL,OAAO,MAAMW,oBAAoB,GAAGA,CAACC,KAAW,EAAET,UAAoB,KAAgB;EAClF,MAAMU,aAAyB,GAAG,EAAE;EACpC,MAAMP,aAAa,GAAIM,KAAK,CAACZ,IAAI,KAAKL,QAAQ,CAACU,GAAG,GAAG,CAAC,GAAC,CAAC,CAAC;EAGzD,KAAI,IAAIG,CAAC,GAAC,CAAC,EAACA,CAAC,GAAC,CAAC,EAACA,CAAC,EAAE,EAAC;IAChB,KAAI,IAAID,CAAC,GAAC,CAAC,CAAC,EAACA,CAAC,GAAC,CAAC,EAACA,CAAC,EAAE,EAAC;MACjB;MACA,IAAGA,CAAC,KAAG,CAAC,EAAE;MAEV,MAAMR,eAAe,GAAG;QAACQ,CAAC,EAACK,KAAK,CAACE,QAAQ,CAACP,CAAC,GAAGA,CAAC;QAAEC,CAAC,EAACI,KAAK,CAACE,QAAQ,CAACN,CAAC,GAAGF;MAAa,CAAC;MACpF,IAAGT,QAAQ,CAACe,KAAK,CAACE,QAAQ,EAAEf,eAAe,EAAEa,KAAK,CAACZ,IAAI,EAAEO,CAAC,EAAED,aAAa,EAAEH,UAAU,CAAC,EAAC;QACnFU,aAAa,CAACE,IAAI,CAAChB,eAAe,CAAC;MACvC;IACJ;EACJ;EAEA,OAAOc,aAAa;AACxB,CAAC;AAAAG,EAAA,GAlBYL,oBAAoB;AAAA,IAAAK,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}