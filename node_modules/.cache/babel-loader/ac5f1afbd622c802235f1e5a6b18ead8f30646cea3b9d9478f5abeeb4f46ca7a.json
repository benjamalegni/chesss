{"ast":null,"code":"import { TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\";\nexport const pawnMove = (initialPosition, desiredPosition, team, dx, dy, boardState) => {\n  const specialRow = team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n  if (initialPosition.x === desiredPosition.x && initialPosition.y === specialRow && dy === 2 * pawnDirection) {\n    if (!Referee.tileIsOccupied(desiredPosition, boardState) && !Referee.tileIsOccupied({\n      x: desiredPosition.x,\n      y: desiredPosition.y - pawnDirection\n    }, boardState)) {\n      return true;\n    }\n  } else if (initialPosition.x === desiredPosition.x && dy === pawnDirection) {\n    return !Referee.tileIsOccupied(desiredPosition, boardState);\n  }\n  //attack\n  else if (dy === pawnDirection && (dx === -1 || dx === 1)) {\n    return Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  return false;\n};\nexport const GetPossiblePawnMoves = (piece, boardState) => {\n  const possibleMoves = [];\n  const pawnDirection = piece.team === TeamType.OUR ? 1 : -1;\n  const specialRow = piece.team === TeamType.OUR ? 1 : 6;\n\n  // Define all possible pawn moves\n  const moves = [\n  // Forward moves\n  {\n    x: 0,\n    y: 1\n  },\n  // One square forward\n  {\n    x: 0,\n    y: 2\n  },\n  // Two squares forward (only from starting position)\n  // Diagonal captures\n  {\n    x: -1,\n    y: 1\n  },\n  // Capture left\n  {\n    x: 1,\n    y: 1\n  } // Capture right\n  ];\n  for (const move of moves) {\n    const desiredPosition = {\n      x: piece.position.x + move.x,\n      y: piece.position.y + move.y * pawnDirection\n    };\n\n    // Skip two-square move if not in starting position\n    if (move.y === 2 && piece.position.y !== specialRow) continue;\n    if (pawnMove(piece.position, desiredPosition, piece.team, move.x, move.y * pawnDirection, boardState)) {\n      possibleMoves.push(desiredPosition);\n    }\n  }\n\n  // Check en passant moves\n  if (Referee.isEnPassantMove(piece.position, {\n    x: piece.position.x - 1,\n    y: piece.position.y + pawnDirection\n  }, piece.type, piece.team, boardState)) {\n    possibleMoves.push({\n      x: piece.position.x - 1,\n      y: piece.position.y + pawnDirection\n    });\n  }\n  if (Referee.isEnPassantMove(piece.position, {\n    x: piece.position.x + 1,\n    y: piece.position.y + pawnDirection\n  }, piece.type, piece.team, boardState)) {\n    possibleMoves.push({\n      x: piece.position.x + 1,\n      y: piece.position.y + pawnDirection\n    });\n  }\n  return possibleMoves;\n};\n_c = GetPossiblePawnMoves;\nvar _c;\n$RefreshReg$(_c, \"GetPossiblePawnMoves\");","map":{"version":3,"names":["TeamType","Referee","pawnMove","initialPosition","desiredPosition","team","dx","dy","boardState","specialRow","OUR","pawnDirection","x","y","tileIsOccupied","tileIsOccupiedByOpponent","GetPossiblePawnMoves","piece","possibleMoves","moves","move","position","push","isEnPassantMove","type","_c","$RefreshReg$"],"sources":["/home/Outer/Documents/chesss/src/referee/rules/PawnRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\n\n    export const pawnMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, boardState:Piece[]):boolean=>{\n            const specialRow = (team === TeamType.OUR)?1:6;\n            const pawnDirection = (team === TeamType.OUR)? 1:-1;\n\n            if(initialPosition.x===desiredPosition.x && initialPosition.y===specialRow && dy===2*pawnDirection){\n                if(!Referee.tileIsOccupied(desiredPosition,boardState) && !Referee.tileIsOccupied({x: desiredPosition.x, y:desiredPosition.y-pawnDirection}, boardState)){\n                    return true;\n                }\n            }else if(initialPosition.x===desiredPosition.x && dy===pawnDirection){\n                    return !Referee.tileIsOccupied(desiredPosition,boardState)\n            }\n            //attack\n            else if(dy===pawnDirection && ((dx===-1) || (dx===1))){\n                return Referee.tileIsOccupiedByOpponent(desiredPosition,boardState,team);\n            }\n        return false;\n    }\n\nexport const GetPossiblePawnMoves = (piece:Piece, boardState : Piece[]):Position[] => {\n    const possibleMoves:Position [] = [];\n    const pawnDirection = (piece.team === TeamType.OUR)? 1:-1;\n    const specialRow = (piece.team === TeamType.OUR)? 1:6;\n\n    // Define all possible pawn moves\n    const moves = [\n        // Forward moves\n        {x: 0, y: 1},  // One square forward\n        {x: 0, y: 2},  // Two squares forward (only from starting position)\n        // Diagonal captures\n        {x: -1, y: 1}, // Capture left\n        {x: 1, y: 1}   // Capture right\n    ];\n\n    for(const move of moves) {\n        const desiredPosition = {\n            x: piece.position.x + move.x,\n            y: piece.position.y + (move.y * pawnDirection)\n        };\n\n        // Skip two-square move if not in starting position\n        if(move.y === 2 && piece.position.y !== specialRow) continue;\n\n        if(pawnMove(piece.position, desiredPosition, piece.team, move.x, move.y * pawnDirection, boardState)) {\n            possibleMoves.push(desiredPosition);\n        }\n    }\n\n    // Check en passant moves\n    if(Referee.isEnPassantMove(piece.position, {x:piece.position.x-1, y:piece.position.y + pawnDirection}, piece.type, piece.team, boardState)) {\n        possibleMoves.push({x:piece.position.x-1, y:piece.position.y + pawnDirection});\n    }\n    if(Referee.isEnPassantMove(piece.position, {x:piece.position.x+1, y:piece.position.y + pawnDirection}, piece.type, piece.team, boardState)) {\n        possibleMoves.push({x:piece.position.x+1, y:piece.position.y + pawnDirection});\n    }\n\n    return possibleMoves;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}