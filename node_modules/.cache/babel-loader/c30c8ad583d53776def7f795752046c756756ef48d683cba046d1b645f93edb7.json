{"ast":null,"code":"import Referee from\"../Referee\";export const bishopMove=(initialPosition,desiredPosition,team,dx,dy,stepX,stepY,boardState)=>{// diagonal movement implies that difference between axis should be equal\nif(Math.abs(dx)===Math.abs(dy)){// iterate all positions between actual position and desired position (dx or dy)\nfor(let i=1;i<Math.abs(dx);i++){// change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\nconst passedPosition={x:initialPosition.x+i*stepX,y:initialPosition.y+i*stepY};// if any intermediate tile is occupied, then is invalid\nif(Referee.tileIsOccupied(passedPosition,boardState)){return false;}}// return true (if is not occupied by our team) or (is ocuppied by opponent)\nreturn!Referee.tileIsOccupied(desiredPosition,boardState)||Referee.tileIsOccupiedByOpponent(desiredPosition,boardState,team);}return false;};","map":{"version":3,"names":["Referee","bishopMove","initialPosition","desiredPosition","team","dx","dy","stepX","stepY","boardState","Math","abs","i","passedPosition","x","y","tileIsOccupied","tileIsOccupiedByOpponent"],"sources":["/home/outer/Documents/chesss/src/referee/rules/BishopRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\nexport const bishopMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean=>{\n            // diagonal movement implies that difference between axis should be equal\n            if (Math.abs(dx) === Math.abs(dy)) {\n\n                // iterate all positions between actual position and desired position (dx or dy)\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // change passedPosition in each iteration and multiply with step depending on each of the 4 directions is heading\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (Referee.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !Referee.tileIsOccupied(desiredPosition, boardState) ||\n                    Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n            }\n        return false;\n    }"],"mappings":"AACA,MAAO,CAAAA,OAAO,KAAM,YAAY,CAEhC,MAAO,MAAM,CAAAC,UAAU,CAACA,CAACC,eAAwB,CAAEC,eAAyB,CAAEC,IAAa,CAACC,EAAS,CAAEC,EAAS,CAAEC,KAAY,CAAEC,KAAY,CAAEC,UAAkB,GAAW,CAC/J;AACA,GAAIC,IAAI,CAACC,GAAG,CAACN,EAAE,CAAC,GAAKK,IAAI,CAACC,GAAG,CAACL,EAAE,CAAC,CAAE,CAE/B;AACA,IAAK,GAAI,CAAAM,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGF,IAAI,CAACC,GAAG,CAACN,EAAE,CAAC,CAAEO,CAAC,EAAE,CAAE,CACnC;AACA,KAAM,CAAAC,cAAwB,CAAG,CAC7BC,CAAC,CAAEZ,eAAe,CAACY,CAAC,CAAGF,CAAC,CAAGL,KAAK,CAChCQ,CAAC,CAAEb,eAAe,CAACa,CAAC,CAAGH,CAAC,CAAGJ,KAC/B,CAAC,CAED;AACA,GAAIR,OAAO,CAACgB,cAAc,CAACH,cAAc,CAAEJ,UAAU,CAAC,CAAE,CACpD,MAAO,MAAK,CAChB,CACJ,CAEA;AACA,MAAO,CAACT,OAAO,CAACgB,cAAc,CAACb,eAAe,CAAEM,UAAU,CAAC,EACvDT,OAAO,CAACiB,wBAAwB,CAACd,eAAe,CAAEM,UAAU,CAAEL,IAAI,CAAC,CAC3E,CACJ,MAAO,MAAK,CAChB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}