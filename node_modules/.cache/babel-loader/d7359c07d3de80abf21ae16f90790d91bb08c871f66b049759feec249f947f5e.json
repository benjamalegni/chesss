{"ast":null,"code":"import Referee from\"../Referee\";// rook moves\nconst rookX=[1,-1,0,0];const rookY=[0,0,1,-1];export const rookMove=(initialPosition,desiredPosition,team,dx,dy,stepX,stepY,boardState)=>{// vertical movement\nif(dx===0){// iterate all positions between actual position and desired position dy\nfor(let i=1;i<Math.abs(dy);i++){// maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\nconst passedPosition={x:initialPosition.x,y:initialPosition.y+i*stepY};// if any intermediate tile is occupied, then is invalid\nif(Referee.tileIsOccupied(passedPosition,boardState)){return false;}}}// horizontal movement\nelse if(dy===0){// iterate all positions between actual position and desired position dx\nfor(let i=1;i<Math.abs(dx);i++){// maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\nconst passedPosition={x:initialPosition.x+i*stepX,y:initialPosition.y};// if any intermediate tile is occupied, then is invalid\nif(Referee.tileIsOccupied(passedPosition,boardState)){return false;}}}else{// if its not vertical nor horizontal movement\nreturn false;}// return true (if is not occupied by our team) or (is ocuppied by opponent)\nreturn!Referee.tileIsOccupied(desiredPosition,boardState)||Referee.tileIsOccupiedByOpponent(desiredPosition,boardState,team);};export const GetPossibleRookMoves=(piece,boardState)=>{const possibleMoves=[];for(let i=0;i<4;i++){let x=piece.position.x+rookX[i];let y=piece.position.y+rookY[i];while(x>=0&&x<8&&y>=0&&y<8){const position={x,y};if(rookMove(piece.position,position,piece.team,rookX[i],rookY[i],rookX[i],rookY[i],boardState)){possibleMoves.push(position);}if(Referee.tileIsOccupied(position,boardState)){break;}x+=rookX[i];y+=rookY[i];}}return possibleMoves;};","map":{"version":3,"names":["Referee","rookX","rookY","rookMove","initialPosition","desiredPosition","team","dx","dy","stepX","stepY","boardState","i","Math","abs","passedPosition","x","y","tileIsOccupied","tileIsOccupiedByOpponent","GetPossibleRookMoves","piece","possibleMoves","position","push"],"sources":["/home/Outer/Documents/chesss/src/referee/rules/RookRules.ts"],"sourcesContent":["import { Piece, Position, TeamType } from \"../../Constants\";\nimport Referee from \"../Referee\"\n\n\n// rook moves\nconst rookX = [1, -1, 0, 0];\nconst rookY = [0, 0, 1, -1];\n\nexport const rookMove=(initialPosition:Position, desiredPosition: Position, team:TeamType,dx:number, dy:number, stepX:number, stepY:number, boardState:Piece[]):boolean=>{\n            // vertical movement\n            if (dx === 0){\n                // iterate all positions between actual position and desired position dy\n                for (let i = 1; i < Math.abs(dy); i++) {\n                    // maintain x position and iterate y axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x,\n                        y: initialPosition.y + i * stepY,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (Referee.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } // horizontal movement\n            else if (dy === 0) {\n                // iterate all positions between actual position and desired position dx\n                for (let i = 1; i < Math.abs(dx); i++) {\n                    // maintain y position and iterate x axis from initial position to desiredPosition multiplying by its direction\n                    const passedPosition: Position = {\n                        x: initialPosition.x + i * stepX,\n                        y: initialPosition.y,\n                    };\n\n                    // if any intermediate tile is occupied, then is invalid\n                    if (Referee.tileIsOccupied(passedPosition, boardState)) {\n                        return false;\n                    }\n                }\n            } else {\n            // if its not vertical nor horizontal movement\n            return false;\n        }\n                // return true (if is not occupied by our team) or (is ocuppied by opponent)\n                return !Referee.tileIsOccupied(desiredPosition, boardState) ||\n                    Referee.tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n\n    export const GetPossibleRookMoves = (piece:Piece, boardState:Piece[]):Position[]=>{\n        const possibleMoves:Position[] = [];\n\n        for(let i=0;i<4;i++){\n            let x = piece.position.x + rookX[i];\n            let y = piece.position.y + rookY[i];\n\n            while(x >= 0 && x < 8 && y >= 0 && y < 8){\n                const position = {x, y};\n                if(rookMove(piece.position, position, piece.team, rookX[i], rookY[i], rookX[i], rookY[i], boardState)){\n                    possibleMoves.push(position);\n                }\n                if(Referee.tileIsOccupied(position, boardState)){\n                    break;\n                }\n                \n                x+=rookX[i];\n                y+=rookY[i];\n            }\n        }\n        return possibleMoves;\n    }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}